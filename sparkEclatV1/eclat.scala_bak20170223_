import scala.collection._

object eclat{
	val minSup = 0.5*6
	var p_prefix:Map[Set[Int],Int] = Map()
	def eclat(_prefix:Map[Set[Int],Int], _x:mutable.Map[Int,Set[Int]], _xx:mutable.Map[Int,Set[Int]]){
		var xx = _xx
		var prefix = _prefix
		while(!xx.isEmpty){
			var itemtid = xx.last                  //zi :Tuple2[Int, Set[Int]]
			var isup = itemtid._2.size
			xx = xx.dropRight(1)
			if(isup >= minSup && !(xx.keys.toSet & _x.keys.toSet).isEmpty){   //zi 取最后一个item_tid，如果满足最小支持度，并与剩余的(itemSet,TIDs)做交集。
				prefix += (itemtid._2 -> isup)
				p_prefix ++= prefix
				println(p_prefix)
				var suffix:mutable.Map[Int, Set[Int]] = mutable.Map()
			    for(itremain <- xx){                                          //zi 剩余的(itemSet,TIDs)与之交集，且满足最小支持度的，递归到下一次计算。
					var tids = itemtid._2 & itremain._2
					if(tids.size > minSup){
						suffix += (itremain)
					}
				}
				eclat(prefix,_x,suffix)
			}
        }
		p_prefix
	}
	def main(args:Array[String]){
		var xx:mutable.Map[Int,Set[Int]] = mutable.Map(11->Set(3,4,5,6), 22->Set(1,2,3), 33->Set(4,6), 44->Set(1,3,5), 55->Set(1,2,4,5,6), 66->Set(1,2,4,6))
		var x = xx
		eclat(Map(), x, xx)
		println("\n")
		println(p_prefix)

	}
}
